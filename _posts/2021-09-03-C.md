---
layout: post
title: BOJ 2482 색상환
subtitle: Algorithm Solution
thumbnail-img: /assets/img/2482.png
tags: [algorithm]
comments: true
---
# 2482 색상환(DP)

## 문제

![problem](/assets/img/pro1.png)

![problem](/assets/img/pro2.png)

## 해결방법

- 원형으로 먼저 생각하지 않고, 선형으로 먼저 생각한다.
- **N번째 색을 선택할 경우**는 N-2개의  색에서 K-1개의 색을 선택하는 경우와 같다. 인접한 칸과 해당 칸을 제외하고 K-1개의 색을 뽑는 것이다.
- **N번째 색을 선택하지 않는 경우**는 N-1개의 색에서 K개의 색을 선택하는 경우와 같다.

![/assets/img/2482.png](/assets/img/2482.png)

- 원형이라면, 색을 선택할 때, 인접하는 색이 2경우 이므로 N-3개의 색에서 K-1개의 색을 선택하는 것으로 생각하면 된다.
**dp[n][k] = dp[n-3][k-1] + dp[n-1][k]**

## 코드

```cpp
#include <iostream>

using namespace std;

int dp[1001][1001];

int main(){
	int N, K;

	cin >> N;
	cin >> K;

	for(int i=0; i<=N; i++){
		dp[i][0] = 1;
		dp[i][1] = i;
	}

	for(int i=2; i<=N; i++){
		for(int j=1; j<=K; j++){

			dp[i][j] = (dp[i-2][j-1] + dp[i-1][j]) % 1000000003;
		}
	}

	cout << (dp[N-3][K-1] + dp[N-1][K])% 1000000003;

	return 0;
}
```